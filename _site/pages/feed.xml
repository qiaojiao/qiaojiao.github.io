<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小杰的博客</title>
    <description>小杰的博客
</description>
    <link>http://blog.qcdcool.com/</link>
    <atom:link href="http://blog.qcdcool.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 04 Mar 2016 17:56:25 +0800</pubDate>
    <lastBuildDate>Fri, 04 Mar 2016 17:56:25 +0800</lastBuildDate>
    <generator>Jekyll v1.4.2</generator>
    
      <item>
        <title>如何使用mkdown写博客</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;撰写博客&lt;/h2&gt;

&lt;p&gt;Jeklly 的一个最好的特点是『关注 blog 本身』。这是指什么呢？简单的说就是写博客的过程被铸造进了 Jekyll 的功能中。你只需简单的管理你电脑中的一个文件夹下的文本文件就可以写文章并方便的在线上发布。与繁琐的配置和维护数据库和基于网站的内容管理系统 (CMS) 相比，这是一个非常受欢迎的改变。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文章文件夹&lt;/h2&gt;
&lt;p&gt;在目录结构介绍中说明过，所有的文章都在_posts文件夹中。这些文件可以用 Markdown 编写，也可以用 Textile 格式编写。只要文件中有 YAML 头信息，它们就会从源格式转化成 HTML 页面，从而成为你的静态网站的一部分&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;创建文章的文件&lt;/h2&gt;
&lt;p&gt;发表一篇新文章，你所需要做的就是在_posts文件夹中创建一个新的文件。文件名的命名非常重要。Jekyll 要求一篇文章的文件名遵循下面的格式：&lt;/p&gt;

&lt;p&gt;年-月-日-标题.MARKUP&lt;/p&gt;

&lt;p&gt;在这里，年是4位数字，月和日都是2位数字。MARKUP扩展名代表了这篇文章是用什么格式写的。下面是一些合法的文件名的例子：&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://blog.qcdcool.com/2016/03/04/how-to-write-blog-with-mkdown.html</link>
        <guid isPermaLink="true">http://blog.qcdcool.com/2016/03/04/how-to-write-blog-with-mkdown.html</guid>
        
        <category>Blog</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Vim 常用资源</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;在粘贴代码时不启动自动缩进&lt;/h2&gt;

&lt;p&gt;粘贴之前输入 &lt;code&gt;:set paste&lt;/code&gt;
粘贴完后恢复 &lt;code&gt;:set nopaste&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关闭和开启行号&lt;/h2&gt;

&lt;p&gt;关闭 &lt;code&gt;:set nonu&lt;/code&gt;
开启 &lt;code&gt;:set number&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 04 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://blog.qcdcool.com/2015/10/04/general-vim-resources.html</link>
        <guid isPermaLink="true">http://blog.qcdcool.com/2015/10/04/general-vim-resources.html</guid>
        
        <category>Vim</category>
        
        
        <category>资源</category>
        
      </item>
    
      <item>
        <title>七种常见经典排序算法总结（C++实现）</title>
        <description>&lt;p&gt;排序算法是非常常见也非常基础的算法，以至于大部分情况下它们都被集成到了语言的辅助库中。排序算法虽然已经可以很方便的使用，但是理解排序算法可以帮助我们找到解题的方向。&lt;/p&gt;

&lt;h2 id=&quot;bubble-sort&quot;&gt;1. 冒泡排序 (Bubble Sort)&lt;/h2&gt;

&lt;p&gt;冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从左开始比较相邻的两个元素x和y，如果 x &amp;gt; y 就交换两者&lt;/li&gt;
  &lt;li&gt;执行比较和交换，直到到达数组的最后一个元素&lt;/li&gt;
  &lt;li&gt;重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;CPP
void bubble_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums)
{
    for (int i = 0; i &amp;lt; nums.size() - 1; i++) { // times
        for (int j = 0; j &amp;lt; nums.size() - i - 1; j++) { // position
            if (nums[j] &amp;gt; nums[j + 1]) {
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;交换的那一步可以不借助temp，方法是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CPP
nums[j] += nums[j + 1];
nums[j + 1] = num[j] - nums[j + 1];
nums[j] -= num[j + 1];
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是&lt;code&gt;(a1 + an) * n / 2&lt;/code&gt;），也就是 &lt;code&gt;O(n^2)&lt;/code&gt;。 空间复杂度是&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;2. 插入排序（Insertion Sort）&lt;/h2&gt;

&lt;p&gt;插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从左开始，选出当前位置的数x，和它之前的数y比较，如果x &amp;lt; y则交换两者&lt;/li&gt;
  &lt;li&gt;对x之前的数都执行1步骤，直到前面的数字都有序&lt;/li&gt;
  &lt;li&gt;选择有序部分后一个数字，插入到前面有序部分，直到没有数字可选择&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;CPP
void insert_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums)
{
    for (int i = 1; i &amp;lt; nums.size(); i++) { // position
        for (int j = i; j &amp;gt; 0; j--) {
            if (nums[j] &amp;lt; nums[j - 1]) {
                int temp = nums[j];
                nums[j] = nums[j - 1];
                nums[j - 1] = temp;
            }
        }
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是&lt;code&gt;O(n^2)&lt;/code&gt;。空间复杂度是&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;3. 选择排序（Selection Sort）&lt;/h2&gt;

&lt;p&gt;选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从左开始，选择后面元素中最小值，和最左元素交换&lt;/li&gt;
  &lt;li&gt;从当前已交换位置往后执行，直到最后一个元素&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```CPP
void selection_sort(vector&lt;int&gt; &amp;amp;nums)
{
    for (int i = 0; i &amp;lt; nums.size(); i++) { // position
        int min = i;
        for (int j = i + 1; j &amp;lt; nums.size(); j++) {
            if (nums[j] &amp;lt; nums[min]) {
                min = j;
            }
        }&lt;/int&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int temp = nums[i];
    nums[i] = nums[min];
    nums[min] = temp;
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是&lt;code&gt;O(n^2)&lt;/code&gt;。空间复杂度是&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;shell-sort&quot;&gt;4. 希尔排序（Shell Sort）&lt;/h2&gt;

&lt;p&gt;希尔排序从名字上看不出来特点，因为它是以发明者命名的。它的另一个名字是“递减增量排序算法“。这个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如 &lt;code&gt;[10, 80, 70, 100, 90, 30, 20]&lt;/code&gt;
如果我们按照一次减一半的步长来算， 这个数组第一次排序时以3为步长，子数组是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;10 80 70&lt;/code&gt;
&lt;code&gt;90 30 20&lt;/code&gt;
&lt;code&gt;100&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里其实按照列划分的4个子数组，排序后结果为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;10 30 20&lt;/code&gt;
&lt;code&gt;90 80 70&lt;/code&gt;
&lt;code&gt;100&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也就是 &lt;code&gt;[10, 30 20 90 80 70 100]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后再以1为步长生成子数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;10&lt;/code&gt;
&lt;code&gt;30&lt;/code&gt;
&lt;code&gt;20&lt;/code&gt;
&lt;code&gt;..&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个时候就是一纵列了，也就是说最后一定是以一个数组来排序的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算当前步长，按步长划分子数组&lt;/li&gt;
  &lt;li&gt;子数组内插入排序&lt;/li&gt;
  &lt;li&gt;步长除以2后继续12两步，直到步长最后变成1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```CPP
void shell_sort(vector&lt;int&gt; &amp;amp;nums)
{
    for (int gap = nums.size() &amp;gt;&amp;gt; 1; gap &amp;gt; 0; gap &amp;gt;&amp;gt;= 1) { // times
        for (int i = gap; i &amp;lt; nums.size(); i++) { // position
            int temp = nums[i];&lt;/int&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        int j = i - gap;
        for (; j &amp;gt;= 0 &amp;amp;&amp;amp; nums[j] &amp;gt; temp; j -= gap) {
            nums[j + gap] = nums[j];
        }

        nums[j + gap] = temp;
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;希尔排序的时间复杂度受步长的影响，具体分析在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97&quot;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;merge-sort&quot;&gt;5. 归并排序（Merge Sort）&lt;/h2&gt;

&lt;p&gt;归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;把当前数组分化成n个单位为1的子数组，然后两两比较合并成单位为2的n/2个子数组&lt;/li&gt;
  &lt;li&gt;继续进行这个过程，按照2的倍数进行子数组的比较合并，直到最终数组有序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```CPP
void merge_array(vector&lt;int&gt; &amp;amp;nums, int b, int m, int e, vector&lt;int&gt; &amp;amp;temp)
{
    int lb = b, rb = m, tb = b;
    while (lb != m &amp;amp;&amp;amp; rb != e)
        if (nums[lb] &amp;lt; nums[rb])
            temp[tb++] = nums[lb++];
        else
            temp[tb++] = nums[rb++];&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (lb &amp;lt; m)
    temp[tb++] = nums[lb++];

while (rb &amp;lt; e)
    temp[tb++] = nums[rb++];

for (int i = b;i &amp;lt; e; i++)
    nums[i] = temp[i]; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;void merge_sort(vector&lt;int&gt; &amp;amp;nums, int b, int e, vector&lt;int&gt; &amp;amp;temp)
{
    int m = (b + e) / 2;
    if (m != b) {
        merge_sort(nums, b, m, temp);
        merge_sort(nums, m, e, temp);
        merge_array(nums, b, m, e, temp);
    }
}
```&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;这个实现中加了一个temp，是和原数组一样大的一个空间，用来临时存放排序后的子数组的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;merge_array&lt;/code&gt;过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是&lt;code&gt;logn&lt;/code&gt;。所以这个算法最终时间复杂度是&lt;code&gt;O(nlogn)&lt;/code&gt;，空间复杂度是&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;quick-sort&quot;&gt;6. 快速排序（Quick Sort）&lt;/h2&gt;

&lt;p&gt;快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用一个基准数将数组分成两个子数组&lt;/li&gt;
  &lt;li&gt;将大于基准数的移到右边，小于的移到左边&lt;/li&gt;
  &lt;li&gt;递归的对子数组重复执行1，2，直到整个数组有序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```CPP
void quick_sort(vector&lt;int&gt; &amp;amp;nums, int b, int e, vector&lt;int&gt; &amp;amp;temp)
{
    int m = (b + e) / 2;
    if (m != b) {
        int lb = b, rb = e - 1;&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (int i = b; i &amp;lt; e; i++) {
        if (i == m)
            continue;
        if (nums[i] &amp;lt; nums[m])
            temp[lb++] = nums[i];
        else
            temp[rb--] = nums[i];
    }
    temp[lb] = nums[m];
    
    for (int i = b; i &amp;lt; e; i++)
        nums[i] = temp[i];
    
    quick_sort(nums, b, lb, temp);
    quick_sort(nums, lb + 1, e, temp);
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解法2: 不需要辅助空间&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CPP
void quick_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums, int b, int e)
{
    if (b &amp;lt; e - 1) {
        int lb = b, rb = e - 1;
        while (lb &amp;lt; rb) {
            while (nums[rb] &amp;gt;= nums[b] &amp;amp;&amp;amp; lb &amp;lt; rb)
                rb--;
            while (nums[lb] &amp;lt;= nums[b] &amp;amp;&amp;amp; lb &amp;lt; rb)
                lb++;
            swap(nums[lb], nums[rb]);
        }
        swap(nums[b], nums[lb]);
        quick_sort(nums, b, lb);
        quick_sort(nums, lb + 1, e);
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;快速排序也是一个不稳定排序，时间复杂度看&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#.E5.B9.B3.E5.9D.87.E8.A4.87.E9.9B.9C.E5.BA.A6&quot;&gt;维基百科&lt;/a&gt;。空间复杂度是&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;heap-sort&quot;&gt;7. 堆排序（Heap Sort）&lt;/h2&gt;

&lt;p&gt;堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。&lt;/p&gt;

&lt;p&gt;在了解算法之前，首先了解在一维数组中节点的下标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;i节点的父节点 parent(i) = floor((i-1)/2)&lt;/li&gt;
  &lt;li&gt;i节点的左子节点 left(i) = 2i + 1&lt;/li&gt;
  &lt;li&gt;i节点的右子节点 right(i) = 2i + 2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造最大堆（Build Max Heap）：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。&lt;/li&gt;
  &lt;li&gt;最大堆调整（Max Heapify）：调整最大堆即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。&lt;/li&gt;
  &lt;li&gt;堆排序（HeapSort）：重复执行2，直到所有根节点都已移除。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```CPP
void heap_sort(vector&lt;int&gt; &amp;amp;nums)
{
    int n = nums.size();
    for (int i = n / 2 - 1; i &amp;gt;= 0; i--) { // build max heap
        max_heapify(nums, i, nums.size() - 1);
    }&lt;/int&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = n - 1; i &amp;gt; 0; i--) { // heap sort
    int temp = nums[i];
    num[i] = nums[0];
    num[0] = temp;
    max_heapify(nums, 0, i);
} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;void max_heapify(vector&lt;int&gt; &amp;amp;nums, int beg, int end)
{
    int curr = beg;
    int child = curr * 2 + 1;
    while (child &amp;lt; end) {
        if (child + 1 &amp;lt; end &amp;amp;&amp;amp; nums[child] &amp;lt; nums[child + 1]) {
            child++;
        }
        if (nums[curr] &amp;lt; nums[child]) {
            int temp = nums[curr];
            nums[curr] = nums[child];
            num[child] = temp;
            curr = child;
            child = 2 * curr + 1;
        } else {
            break;
        }
    }
}
```&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;堆执行一次调整需要&lt;code&gt;O(logn)&lt;/code&gt;的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是&lt;code&gt;O(nlogn)&lt;/code&gt;。空间复杂度是&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;0. 参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;维基百科&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/&quot;&gt;经典排序算法总结与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000002466215&quot;&gt;堆排序C++实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/&quot;&gt;常见排序算法 - 堆排序 (Heap Sort)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 07 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://blog.qcdcool.com/2015/09/07/sort-algorithms.html</link>
        <guid isPermaLink="true">http://blog.qcdcool.com/2015/09/07/sort-algorithms.html</guid>
        
        <category>算法</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>使用 Zipcar 在加州租车</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在洛杉矶这个“大饼”中生活，没有车真的是各种艰难。2月初把驾照考过了，接下来就考虑买车或者租车。买车算了算不是很划算，而且对车也不太懂，就考虑先租车。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 &lt;a href=&quot;http://transnet.usc.edu/index.php/getting-around/&quot;&gt;USC Transportation&lt;/a&gt; 上排名最靠前的两个公司是 Enterprise 和 Zipcar。前者是传统的租车公司，后者稍微不一样一点。我还没有在 Enterprise 上租过车，所以先说说 Zipcar.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;zipcar-&quot;&gt;Zipcar 简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zipcar.com&quot;&gt;Zipcar&lt;/a&gt; 是会员制的，在注册以后会给发一张 Zipcard 过来，有了这张卡你就可以随时去订车和提车了。Zipcar 不像其他租车行一样你得去固定地方统一取车，它的车就停在路边，他们有固定的停车位。来看一下 Zipcar 在 USC 附近的停车点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-zipcar-map.png&quot; alt=&quot;zipcar map&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;zipcar--1&quot;&gt;Zipcar 使用&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 注册获得会员卡&lt;/h3&gt;

&lt;p&gt;大部分学校应该都和 Zipcar 有合作，所以注册之前应该去学校网站看一下。学生可以将会员费缩减到 25刀/年。&lt;/p&gt;

&lt;p&gt;注册地址在&lt;a href=&quot;http://members.zipcar.com/registration&quot;&gt;这里&lt;/a&gt;，注册的时候去搜一下 Promo Code，我就是注册完才看到一个免费40刀的 Code T_T。在美国注册帐号一看到 Code 填空就应该去搜搜~&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 租车&lt;/h3&gt;

&lt;p&gt;租车可以在网站上或者手机 APP 上进行。租车非常方便，只要选择相应车辆，以及使用时间预订即可。然后在预订时间的前15分钟内取车。取车很简单，拿自己的 Zipcard 刷一下车前部的一个感应器门就开了。然后上车发动走人。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 加油&lt;/h3&gt;

&lt;p&gt;Zipcar 租的车带了加油卡，就在司机座位上面。虽然看起来比较贴心，但是这个卡经常不能用，因为它似乎是个信用卡，然后一旦有人尝试多次失败就被锁了，导致后面的人们也不能用。&lt;/p&gt;

&lt;p&gt;加油卡的使用方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;刷一下加油卡 (Gas Card)&lt;/li&gt;
  &lt;li&gt;输入汽车里程表上的数&lt;/li&gt;
  &lt;li&gt;输入 Zipcard 上面那个 6 位的 Gas ID&lt;/li&gt;
  &lt;li&gt;加油&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果加油卡失效，这个时候会提示：Find your cashier。不用担心，直接用自己的信用卡加油就好了，然后记得要收据 (Receipt)，然后把收据发到 support@zipcar.com 报销就好。记得在邮件里加上自己的 Zipcard ID.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 还车&lt;/h3&gt;

&lt;p&gt;还车记得一定要还到原车的位置。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5. 保险&lt;/h3&gt;

&lt;p&gt;在帐号注册的时候有个保险选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-zipcar-damage-fee.png&quot; alt=&quot;damage fee&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我建议选择那个complete waiver，毕竟开车难免磕碰。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注意&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;1. 逾期罚款&lt;/h3&gt;

&lt;p&gt;租车的时候宁可多不可少，因为逾期惩罚是非常重的，应该是一个小时50刀左右。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://blog.qcdcool.com/2015/04/13/rent-car-by-zipcar.html</link>
        <guid isPermaLink="true">http://blog.qcdcool.com/2015/04/13/rent-car-by-zipcar.html</guid>
        
        <category>Essay</category>
        
        
        <category>生活</category>
        
      </item>
    
      <item>
        <title>使用Dropzone和七牛云存储来优化博客图床</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;2015.12.20更新
- 此次更新用Python替代了Ruby，不需要再自己安装qiniu的ruby包，我已经集成在bundle里面
- 增加了一个pngpaste在包里，这样直接点击action会把剪切板内的图片上传 (已测试系统截图，QQ截图以及Monosnap)，原来的点击打开七牛官网功能在剪切版没有图片时生效
- 增加了图片重名检查&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前我在用SAE的Storage作为博客图床，但是令我非常不爽的是没有一个很好的上传和获得公共链接的方法。现在总算用Dropzone和七牛把这个问题解决了，下面是我上传图片和获得URL的操作，方法再往下看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-workflow.gif&quot; alt=&quot;七牛操作流&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;设置七牛帐号&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.qiniu.com&quot;&gt;七牛&lt;/a&gt;是国内口碑不错的一个云存储为主的公司。它的特点应该就在图片存储上，有非常方便的上传SDK和图片处理流，用来作为博客图床非常合适，而且价格不贵，每月有免费的10G流量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;去七牛注册帐号&lt;/p&gt;

    &lt;p&gt;刚刚创建的帐号是测试帐号，完成个人认证就可以成为标准帐号，获得10G的存储空间和各10G的上传下载流量。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-normal-account.png&quot; alt=&quot;标准帐号&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个空间&lt;/p&gt;

    &lt;p&gt;创建空间也比较容易，记得选择公开空间。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-create-bucket.png&quot; alt=&quot;创建空间&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dropzone&quot;&gt;设置Dropzone&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://aptonic.com/dropzone3/&quot;&gt;Dropzone&lt;/a&gt;是我很早就非常喜欢的一个软件。它通过拖拽的方式，增强了文件的处理流程。一直懒得给它开发插件，没想到七牛的SDK如此好用，所以今天折腾了一下搞定了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载软件&lt;/p&gt;

    &lt;p&gt;这个软件可以在App Store上直接购买，但是买到的是功能受限的，它不能操作外部文件。不过没有关系，再从官网上下载非沙箱版本，然后覆盖掉Application文件夹下的即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装Qiniu插件&lt;/p&gt;

    &lt;p&gt;我把这个插件放到了&lt;a href=&quot;https://github.com/suyan/scripts/tree/master/Dropzone%20Action&quot;&gt;Github&lt;/a&gt;上，戳&lt;a href=&quot;https://github.com/suyan/scripts/blob/master/Dropzone%20Action/Qiniu.dzbundle.zip?raw=true&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装插件&lt;/p&gt;

    &lt;p&gt;下载后的是一个zip包，把这个包解压以后双击安装即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用插件&lt;/p&gt;

    &lt;p&gt;从增加列表中选择我们安装好的七牛插件。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-use-bundle.png&quot; alt=&quot;启用插件&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;然后填写配置：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;server: 七牛上的空间名&lt;/li&gt;
      &lt;li&gt;username: 七牛的access_key&lt;/li&gt;
      &lt;li&gt;password: 七牛的secret_key&lt;/li&gt;
      &lt;li&gt;remote path(可选): 本地同步图片的目录，如果你希望本地也存一份图片，选一个地址即可&lt;/li&gt;
      &lt;li&gt;root url: 七牛的公共链接根目录&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-access-key.png&quot; alt=&quot;access key&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-root-url.png&quot; alt=&quot;root url&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;其他建议&lt;/h2&gt;

&lt;p&gt;利用Dropzone还有很多可利用的技巧，例如增加一个ImageOptim应用来压缩图片，然后再进行上传。&lt;/p&gt;

&lt;p&gt;对于临时图片，可以直接上传到Imgur获得链接。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://blog.qcdcool.com/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html</link>
        <guid isPermaLink="true">http://blog.qcdcool.com/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html</guid>
        
        <category>Blog</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>2014阅读书单</title>
        <description>&lt;h2 id=&quot;web&quot;&gt;Web前端黑客技术揭秘&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: 钟晨鸣/徐少培&lt;/li&gt;
  &lt;li&gt;publisher: 电子工业出版社&lt;/li&gt;
  &lt;li&gt;language: 中文&lt;/li&gt;
  &lt;li&gt;link: http://book.douban.com/subject/20451827/&lt;/li&gt;
  &lt;li&gt;cover: http://img3.douban.com/lpic/s24562945.jpg&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-little-redis-book&quot;&gt;The Little Redis Book&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: Karl Seguin&lt;/li&gt;
  &lt;li&gt;publisher: Github&lt;/li&gt;
  &lt;li&gt;language: English&lt;/li&gt;
  &lt;li&gt;link: https://github.com/karlseguin/the-little-redis-book&lt;/li&gt;
  &lt;li&gt;cover: https://raw.githubusercontent.com/karlseguin/the-little-redis-book/master/en/title.png&lt;/li&gt;
  &lt;li&gt;description:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;facebook&quot;&gt;打造Facebook&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: 王淮/祝文让&lt;/li&gt;
  &lt;li&gt;publisher: 印刷工业出版社&lt;/li&gt;
  &lt;li&gt;language: 中文&lt;/li&gt;
  &lt;li&gt;link: http://book.douban.com/subject/20471120/&lt;/li&gt;
  &lt;li&gt;cover: http://img3.douban.com/lpic/s24581301.jpg&lt;/li&gt;
  &lt;li&gt;description:&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 14 Mar 2014 00:00:00 +0800</pubDate>
        <link>http://blog.qcdcool.com/2014/03/14/book-list-of-2014.html</link>
        <guid isPermaLink="true">http://blog.qcdcool.com/2014/03/14/book-list-of-2014.html</guid>
        
        
        <category>读书</category>
        
      </item>
    
  </channel>
</rss>
